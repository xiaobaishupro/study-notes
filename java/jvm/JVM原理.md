# JVM原理

#### 1.类的加载过程（简单理解）

**加载阶段**
		简单来说，加载阶段就是将类文件加载到内存中的过程。在加载阶段，JVM 需要完成以下 3 件事：


通过一个类的全限定名来获取定义此类的二进制字节流；


将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
**连接阶段**
		连接阶段又分为：验证阶段（Verification）、准备阶段（Preparation）和解析阶段（Resolution），具体执行的细节如下。
**验证阶段**
		验证阶段也叫做校验阶段，它主要是用来验证加载到内存中的类是否是安全合规的文件，验证的主要动作大概有以下几个（当然，以下细节如果实在记不住也没关系）：


  文件格式校验包括常量池中的常量类型、Class 文件的各个部分是否被删除或被追加了其他信息等；


元数据校验包括父类正确性校验（检查父类是否有被 final 修饰）、抽象类校验等；


字节码校验，此步骤最为关键和复杂，主要用于校验程序中的语义是否合法且符合逻辑；

符号引用校验，对类自身以外比如常量池中的各种符号引用的信息进行匹配性校验。
 **准备阶段**
		准备阶段就开始给类中的静态变量设置默认值了，注意这里不是给静态变量设置初始值，而是设置默认值，二者还是有很大区别的。
举个例子，比如代码中写的内容是：

public static int number = 10;

那么此时是给 number 变量设置的 int 值是默认值 0，而非初始值 10。
**解析阶段**
		解析阶段就是将常量池中的符号引用更换成直接引用了，所谓的符号引用是指以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可；而直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
符号引用和直接引用有一个重要的区别：使用符号引用时被引用的目标不一定已经加载到内存中；而使用直接引用时，引用的目标必定已经存在虚拟机的内存中了。
**初始化阶段**
		初始化阶段，Java 虚拟机真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。到这一步骤之后，类的加载过程就算正式完成了，此时会给静态变量设置初始值，并执行静态代码块的内容。
**总结**
类加载流程总共分为 3 大类，5 个主要流程：

加载阶段（Loading）：将类文件加载到内存。
连接阶段（Linking）

验证阶段（Verification）：类文件安全性效验。
准备阶段（Preparation）：给静态变量设置默认值。
解析阶段（Resolution）：将符号引用转换为直接引用。


初始化阶段（Initialization）：执行静态代码块和给静态变量设置初始值。

#### 2.什么是双亲委派模型？（）

​		双亲委派模  Java 类加载器的一种工作模式，通过这种工作模式，Java 虚拟机将类文件加载到内存中，这样就保证了 Java 程序能够正常的运行起来。

亲委派模型针对的是 Java 虚拟机中三个类加载器的，这三个类加载器分别是：

1. 启动类加载器（Bootstrap ClassLoader）

2. 扩展类加载器（Extension ClassLoader）

3. 应用程序类加载器（Application ClassLoader）

   在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。

   类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

   只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。

   总结：
   
   双亲委派模型是和 Java 中多个类加载器（启动类加载器、扩展加载器、应用程序类加载器）的运行规则，通过这个（双亲委派模型）规则可以避免类的非安全问题和类被重复加载的问题，但它也遇到了一些问题，比如 JNDI 和 JDBC 不能通过这个规则进行加载，它需要通过打破双亲委派的模型的方式来加载。
   
   https://juejin.cn/post/7195577258907729975

#### 3.jvm虚拟机的内存布局

《Java虚拟机规范》中将 JVM 运行时数据区域划分为以下 5 部分：

1. 程序计数器（Program Counter Register）
2. Java虚拟机栈（Java Virtual Machine Stacks）
3. 本地方法栈（Native Method Stack）
4. Java 堆（Java Heap）
5. 方法区（Methed Area）

**程序计数器**

​		我们知道，**CPU 核数是比较少的，而任务（线程）是比较多的，所以真实的情况是，CPU 会不停的切换线程以执行所有的程序**，当然因为（CPU）切换的速度比较快，所以我们是感知不到的，我们感觉好像所有的程序都是一直在执行，其实从微观的层面来看，所有的程序都是切换执行的。

那么问题来了，CPU 一直在切换线程执行任务，那 CPU 再次切换到某个线程时，它是怎么知道当前的线程上次知道到哪了？

这就是程序计数器的作用，**程序计数器里面保存了当前线程执行的行号，这样当 CPU 切换到当前线程时，才能接着上次执行的位置，继续执行**。

> PS：程序计数器中真实记录的是下一行任务的执行指令。程序计数器也是 JVM 运行时数据区中执行最快的一块区域。
>
> 

**jvm虚拟机栈**

​		Java 虚拟机栈是线程私有的区域，它随着线程的创建而创建。它里面保存的是局部变量表（基础数据类型和对象引用地址）和计算过程中的中间结果。Java 虚拟机的内存不需要连续，它只有两个操作：入栈和出栈。

Java 虚拟机栈要么大小固定，要么根据计算动态的扩展和收缩。程序员可以对 Java 虚拟机栈进行初始值的大小设置和最大值的设置。

Java 虚拟机栈出现的异常有两种：

- 当 Java 虚拟机栈大小固定时，如果程序中的栈分配超过了最大虚拟机栈就会出现 StackOverflowError 异常。

- 如果 Java 虚拟机栈是动态扩展的，那么当内存不足时，就会引发 OutOfMemoryError 的异常。

  **java 虚拟机栈主要是管 Java 程序运行的，它保存的是方法的局部变量、方法执行中的部分结果，并参与方法的调用和返回。**

  简单来说，栈是运行时单位，而堆是存储单位。也就是说：栈解决的是程序运行的问题，即程序如何执行？或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放？放在哪儿。

  参数设置

  设置 Java 虚拟机栈大小：-Xss。 如设置：-Xss128k，表示设置每个线程的栈大小为 128k，此设置等价于 -XX:ThreadStackSize=128k。

  

**本地方法栈**

​		本地方法栈俗称“C栈”，它是 Native（本地）方法（用 Java 编程语言以外的语言编写的方法），此区域和 Java 虚拟机栈类似，这不过诸如 C 语言等使用的栈空间。它也是存在两种异常：StackOverflowError 和 OutOfMemoryError。

**堆**

​		堆是线程共享的，程序中所有类实例和数组的内存都存储在此区域，它在 Java 虚拟机启动时就会创建。对象不会被显式释放，只会在垃圾收集时释放。堆的大小可以是固定的，也可以动态扩展或收缩。堆的内存在物理层面不需要是连续的。

程序员可以对堆进行初始大小控制，或者设置最大、最小堆的容量。 堆可能会出现 OutOfMemoryError 异常。

常见参数设置

- -Xms：设置初始 Java 堆大小，比如：-Xms10m，表示设置堆的初始大小为 10MB。
- -Xmx：设置最大 Java 堆大小，比如：-Xmx10m，表示设置堆的最大空间为 10MB。

**方法区**

​		方法区是线程共享的，方法区类似于传统语言的编译代码的存储区，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码。

> ```
> 方法区是各个线程共享的内存区域，它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。
> ```

方法区域是在 Java 虚拟机启动时创建的，尽管方法区域在逻辑上是堆的一部分，但简单的实现可能选择不进行垃圾收集或压缩。方法区域可以是固定的大小，也可以动态扩展。方法区的（物理）内存不需要连续。

Java 虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，以及在可变大小的方法区域的情况下，对最大和最小方法区域大小的控制。

如果方法区中的内存无法满足分配请求，Java 虚拟机将抛出一个 OutOfMemoryError。

https://juejin.cn/post/7196979272154333244

#### 4.JVM 如何确定死亡对象？

**可达分析算法**

​		可达性分析算法（Reachability Analysis） 是目前主流虚拟机中，使用最广泛的判断垃圾对象的实现算法，它指的是从对象的起点（GC Roots）开始向下搜索，如果对象到 GC Roots 没有任何引用链相连时，也就是说此对象到 GC Roots 不可达时，则表示此对象可以被垃圾回收器所回收

#### 5.jvm参数设置

> Xms 起始内存
>
> Xmx 最大内存
>
> Xmn 新生代内存
>
> Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小
>
> -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
>
> -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
>
> -XX:MaxPermSize=n:设置持久代大小
>
> 收集器设置
> -XX:+UseSerialGC:设置串行收集器
> -XX:+UseParallelGC:设置并行收集器
> -XX:+UseParalledlOldGC:设置并行年老代收集器
> -XX:+UseConcMarkSweepGC:设置并发收集器
> 垃圾回收统计信息
> -XX:+PrintGC
> -XX:+PrintGCDetails
> -XX:+PrintGCTimeStamps
> -Xloggc:filename
> 并行收集器设置
> -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
> -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
> -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
> 并发收集器设置
> -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
> -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

