# redis学习

### 何为NoSQL？

NoSQL，泛指非关系型的数据库。

### 何为redis？

Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI [C语言](https://baike.baidu.com/item/C语言?fromModule=lemma_inlink)编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库](https://baike.baidu.com/item/数据库/103728?fromModule=lemma_inlink)，并提供多种语言的API。

### redis安装

[redis](https://github.com/tporadowski/redis/releases)

可视化工具：[redis-desktop-manager](https://resp.app/)

文件目录：

> redis.windows.conf redis的配置文件
>
> redis-benchmark.exe 测试工具，测试redis的读写性能情况
>
> redis-check-aof.exe aof 修复检查日志
>
> redis-check-dump.exe dump 检查数据库文件
>
> redis-cli.exe redis客户端程序
>
> redis-server.exe redis服务器程序

启动服务端服务：切换到redis目录 ，cmd输入

```
redis-server.exe redis.windows.conf
```

启动客户端服务：切换到redis目录 ，cmd输入

```
redis-cli.exe -h 127.0.0.1 -p 6379
```

redis多数情况会在linux平台使用。

### 为什么要使用redis？

因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。

性能：我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

并发：在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

### Redis数据类型

五种基本数据类型**String**、**Hash**、**List**、**Set**、**SortedSet**。

**string**

> 字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。
>
> 这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。
>
> 字符串主要有以下几个典型使用场景：
>
> - 缓存功能
> - 计数
> - 共享Session
> - 限速

**hash**

> 哈希类型是指键值本身又是一个键值对结构。
>
> 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
>
> 哈希主要有以下典型应用场景：
>
> - 缓存用户信息
> - 缓存对象

**list**

> 列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色
>
> 使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适---取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。
>
> 列表主要有以下几种使用场景：
>
> - 消息队列
> - 文章列表

**set**

> 集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。
>
> 因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
>
> 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
>
> 集合主要有如下使用场景：
>
> - 标签（tag）
> - 共同关注

**sorted set**

> 有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。
>
> sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。
>
> 有序集合主要应用场景：
>
> - 用户点赞统计
> - 用户排序

[每种数据类型的使用场景](https://www.cnblogs.com/xiaoxi/p/7007695.html)

### 使用redis产生的问题

- 缓存和数据库双写一致性问题
- 缓存雪崩问题
- 缓存击穿问题
- 缓存的并发竞争问题

### redis这么快的原因

> Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制
- C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼

### 多路复用

引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：

- 第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。
- 第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。
- 第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。

第一种就是阻塞IO模型，第三种就是I/O复用模型。

### redis的使用场景

- 为热点数据加速查询（主要场景），如热点商品，热点新闻，热点资讯，推广类等高访问量信息等

- 任务队列，如秒杀、抢购、购票排队等

- 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息

- 时效性信息控制，如验证码控制。投票控制等

- 分布式数据共享，如分布式集群架构中的session分离

- 消息队列

- 分布式锁

  面试时：Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：

  - Token存储：用户登录成功之后，使用Redis存储Token
  - 登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号
  - 地址缓存：对省市区数据的缓存
  - 分布式锁：分布式环境下登录、注册等操作加分布式锁
  - ……

### redis客户端和服务端

• 服务器经过初始化之后，才能开始接受命令。
• 服务器初始化可以分为六个步骤：

　　1. 初始化服务器全局状态。
　　2. 载入配置文件。
　　3. 创建 daemon 进程。
　　4. 初始化服务器功能模块。
　　5. 载入数据。
　　6. 开始事件循环。
• 服务器为每个已连接的客户端维持一个客户端结构，这个结构保存了这个客户端的所有
状态信息。
• 客户端向服务器发送命令，服务器接受命令然后将命令传给命令执行器，执行器执行给
定命令的实现函数，执行完成之后，将结果保存在缓存，最后回传给客户端。

### redis持久化

Redis持久化⽅案分为RDB和AOF两种。

**RDB**

RDB持久化是把当前进程数据生成**快照**保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。

RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。

手动触发分别对应save和bgsave命令:

> save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。
>
> bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。

以下场景会自动触发RDB持久化：

- 使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。
- 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点
- 执行debug reload命令重新加载Redis时，也会自动触发save操作
- 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave

**AOF**

AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。

AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）

流程如下：

> 1）所有的写入命令会追加到aof_buf（缓冲区）中。
>
> 2）AOF缓冲区根据对应的策略向硬盘做同步操作。
>
> 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。
>
> 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

### redis事务

**Redis事务的概念：**

事务表示一组动作，要么全部执行要么全部不执行，像`Mysql`中的事务还是挺复杂的，要保证事务四大特征(ACID)**原子性(A)、一致性 ©、隔离性(I)、持久性(D)**，又会引入像事务的隔离级别等等东西。
 然而 `Redis` 只提供了**简单**的事务功能。本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。命令的执行过程是是原子顺序执行的，但是**不能保证原子性**。

Redis事务相关命令

> watch key1 key2...  #监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则
> 事务被打断 （ 类似乐观锁 ）
> multi # 标记一个事务块的开始（ queued ）
> exec # 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）
> discard # 取消事务，放弃事务块中的所有命令
> unwatch # 取消watch对所有key的监控

### redis高可用

Redis保证高可用主要有三种方式：主从、哨兵、集群。

#### 主从复制

概念：是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 **单向** 的，只能由主节点到从节点。Redis 主从复制支持 **主从同步** 和 **从从同步** 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。

作用：

> **数据冗余：** 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
>
> **故障恢复：** 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。
>
> **负载均衡：** 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 *（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）*，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。
>
> **高可用基石：** 除了上述作用以外，主从复制还是哨兵和集群能够实施的 **基础**，因此说主从复制是 Redis 高可用的基础。

