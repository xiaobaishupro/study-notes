#### 2.25学习记录

##### 1.遍历map

https://juejin.cn/post/7039197348391551013

```java
Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()){
    System.out.println(iterator.next().getKey() + ":" + iterator.next().getValue());
}
```

##### 2.为什么HashMap会产生死循环？

HashMap 死循环发生在 JDK 1.7 版本中，形成死循环的原因是 HashMap 在 JDK 1.7 使用的是头插法，头插法 + 链表 + 多线程并发 + HashMap 扩容，这几个点加在一起就形成了 HashMap 的死循环，解决死锁可以采用线程安全容器 ConcurrentHashMap 替代。 

##### 3.ConcurrentHashMap线程安全的实现？

在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。

Segment 本身是基于 ReentrantLock 实现的加锁和释放锁的操作，这样就能保证多个线程同时访问 ，ConcurrentHashMap 时，同一时间只有一个线程能操作相应的节点，这样就保证了 ConcurrentHashMap 的线程安全了。 也就是说 ConcurrentHashMap 的线程安全是建立在 Segment 加锁的基础上的，所以我们把它称之为分段锁或片段锁。

在 JDK 1.8 中 ConcurrentHashMap 使用的是 CAS + volatile 或 synchronized 的方式来保证线程安全的，在 JDK 1.8 中，添加元素时首先会判断容器是否为空，如果为空则使用 volatile 加 CAS 来初始化。如果容器不为空则根据存储的元素计算该位置是否为空，如果为空则利用 CAS 设置该节点；如果不为空则使用 synchronize 加锁，遍历桶中的数据，替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。


链接：https://juejin.cn/post/7056572041511567367

简单点说：ConcurrentHashMap 在 JDK 1.7 时使用的是数据加链表的形式实现的，其中数组分为两类：大数组 Segment 和小数组 HashEntry，而加锁是通过给 Segment 添加 ReentrantLock 锁来实现线程安全的。而 JDK 1.8 中 ConcurrentHashMap 使用的是数组+链表/红黑树的方式实现的，它是通过 CAS 或 synchronized 来实现线程安全的，并且它的锁粒度更小，查询性能也更高。 

##### 4.元素排序Comparable和Comparator有什么区别？

```java
Collections.sort(list);
list.forEach(System.out::println);

class Person implements Comparable<Person>
    @Override
    public int compareTo(Person o) {
        return this.getAge()-o.getAge();
    }
```

this在前为从小到大；

```java
Collections.sort(list,(p1,p2) -> p2.getAge()-p1.getAge());
或list.forEach(System.out::println);
list.forEach(System.out::println);
```

p1在前为从小到大

##### 5.list去重

LinkedHashSet 来实现；

stream；list.stream().distinct().forEach(System.out::println);

##### 6.ioc和di

**在 new 对象的时代，对象的管理权是由当前类控制的，而有了 IoC 之后，对象的管理权就交给非当前类的 IoC 容器管理了，此时对象的管理权就发生了反转和改变，这就是 IoC，这就是控制（权）反转。**

**依赖注入不是一种设计实现，而是一种具体的技术**，它是**在 IoC 容器运行期间，动态地将某个依赖对象注入到当前对象的技术就叫做 DI（依赖注入）**。

##### 7.进程和线程有什么区别？

进程（Process）是操作系统分配资源的基本单位，一个进程拥有的资源有自己的堆、栈、虚存空间（页表）、文件描述符等信息。

线程（Thread）是操作系统能够进行运算调度的基本单位。它包含在进程中，是进程中的实际运行单位。

https://juejin.cn/post/7062149846639050782

##### 8.说一下线程池7个参数的含义？

corePoolSize：核心线程数。

maximumPoolSize：最大线程数。

keepAliveTime：空闲线程存活时间。

TimeUnit：时间单位。

BlockingQueue：线程池任务队列。

比较常用的是 LinkedBlockingQueue，线程池的排队策略和 BlockingQueue 息息相关。

ThreadFactory：创建线程的工厂。

线程池创建线程时调用的工厂方法，通过此方法可以设置线程的优先级、线程命名规则以及线程类型（用户线程还是守护线程）等

RejectedExecutionHandler：拒绝策略。

线程池的默认策略是 AbortPolicy 拒绝并抛出异常。

================================

corePoolSize：核心线程数，线程池正常情况下保持的线程数，大户人家“长工”的数量。

maximumPoolSize：最大线程数，当线程池繁忙时最多可以拥有的线程数，大户人家“长工”+“短工”的总数量。

keepAliveTime：空闲线程存活时间，没有活之后“短工”可以生存的最大时间。

TimeUnit：时间单位，配合参数 3 一起使用，用于描述参数 3 的时间单位。

BlockingQueue：线程池的任务队列，用于保存线程池待执行任务的容器。

ThreadFactory：线程工厂，用于创建线程池中线程的工厂方法，通过它可以设置线程的命名规则、优先级和线程类型。

RejectedExecutionHandler：拒绝策略，当任务量超过线程池可以保存的最大任务数时，执行的策略。



链接：https://juejin.cn/post/7072921565079273480

##### 9.什么是守护线程？它和用户线程有什么区别？

线程分为两类：用户线程和守护线程，默认情况下我们创建的线程或线程池都是用户线程，所以用户线程也被称之为普通线程。

想要查看线程到底是用户线程还是守护线程，可以通过 Thread.isDaemon() 方法来判断，如果返回的结果是 true 则为守护线程，反之则为用户线程。

护线程（Daemon Thread）也被称之为后台线程或服务线程，守护线程是为用户线程服务的，当程序中的用户线程全部执行结束之后，守护线程也会跟随结束。
链接：https://juejin.cn/post/7075533443450273800

##### 10.为什么创建线程池一定要用ThreadPoolExecutor？

一定要使用 ThreadPoolExecutor 手动的方式来创建线程池，因为这种方式可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。

**11.synchronized底层是如何实现的？**

synchronized 同步锁是通过 JVM 内置的 Monitor 监视器实现的，而监视器又是依赖操作系统的互斥锁 Mutex 实现的。JVM 监视器的执行流程是：线程先通过自旋 CAS 的方式尝试获取锁，如果获取失败就进入 EntrySet 集合，如果获取成功就拥有该锁。当调用 wait() 方法时，线程释放锁并进入 WaitSet 集合，等其他线程调用 notify 或 notifyAll 方法时再尝试获取锁。锁使用完之后就会通知 EntrySet 集合中的线程，让它们尝试获取锁。

**12.为什么创建线程池一定要用ThreadPoolExecutor？**

在 Java 语言中，一定要使用 ThreadPoolExecutor 手动的方式来创建线程池，因为这种方式可以通过参数来控制最大任务数和拒绝策略，让线程池的执行更加透明和可控，并且可以规避资源耗尽的风险。oom（内存溢出）风险。

